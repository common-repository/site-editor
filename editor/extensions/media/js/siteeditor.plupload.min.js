(function($, o) {
   var uploaders = {};

   var SiteEditorUploader = function( id , target , uploaderUI , options ){
        var self = this;

        //self.mediaItems = options.mediaItems;
        //self.errorBox = options.errorBox;
        self.id = id;
        self.options = options;
        self.prefixItemId = options.prefixItemId || "media-item-";
        self.contentsBak = target.html();
        self.target = target;
        self.uploaderUI = uploaderUI;
        self.init();
        self.render();
   };

   SiteEditorUploader.prototype = {
        init: function(){
            var self = this;
            self.containerSelector = '#' + self.id + '-container';
            self.itemsSelector = '#' + self.id + '-items';
            self.errorsSelector = '#' + self.id + '-errors';
            self.browseSelector = '#' + self.id + '-browse';
            self.browseSelector = '#' + self.id + '-browse';

            self.target.html(self.uploaderUI);

            self.mediaItemView = $( ".media-item-progress" ,self.itemsSelector ).html();

            self.mediaItemUploadedView = $( ".media-item-uploaded" ,self.itemsSelector ).html();
            $( self.itemsSelector ).html("");

            self.mediaErrorView = $( self.errorsSelector ).html();
            $( self.errorsSelector ).html("");
        },

        doAction: function(trigger , args){
            var self = this;
            if(args)
                self.target.trigger( trigger, args);
            else
                self.target.trigger( trigger );
        },

        applyFilter: function(){
            /*
            $.when($(this).trigger('custom-event')).done(function(){
                window.location.href = 'url';
            });
            */
        },
        // progress and success handlers for media multi uploads
        fileQueued: function(file) {
            var self = this;

            self.doAction("BeforefileQueued" , [file]);

            $( self.itemsSelector ).show();
            // Create a progress bar containing the filename
            var mediaItem = self.mediaItemView;
            mediaItem = mediaItem.replace("{{file-id}}" , file.id);

            if(self.options.list_items === true){
                $(mediaItem).appendTo( $( self.itemsSelector ) );
            }else{
                $( self.itemsSelector ).html( mediaItem );
            }

            self.doAction("AfterfileQueued" , [file]);
            // Disable submit
            //$('#insert-gallery').prop('disabled', true);
        },

        uploadProgress: function(up, file) {
            var self = this;
            /*
            $('.progressbar', item).progressbar({
              value: (200 * file.loaded) / file.size
            });
        	//$('.bar', item).width( (200 * file.loaded) / file.size );
        	$('.percent', item).html( file.percent + '%' );
            */
            var item = $( '#' + self.prefixItemId + file.id);
            $(".uploader-loading" , item).show();
        },

        uploadSuccess: function(fileObj, serverData) {
            var self = this;

            var item = $('#' + self.prefixItemId + fileObj.id);

            serverData = $.parseJSON(serverData);

            // if async-upload returned an error message, place it in the media item div and return
            if ( serverData.success == false ) {
                item.html("");
                var error = self.mediaErrorView;
                error = error.replace("{{err-code}}" , serverData.data.filename);
                error = error.replace("{{err-message}}" , serverData.data.message);
                $(error).appendTo( $( self.errorsSelector ) );

                return;
            }else{         // url link icon sizes height width type
                var _alt = (serverData.data.alt) ? serverData.data.alt:"",
                    itemUploadedView = self.mediaItemUploadedView , src , fullSrc;

                if(serverData.data.type == "image"){

                    if(typeof serverData.data.sizes.thumbnail != 'undefined'){
                        src = serverData.data.sizes.thumbnail.url;
                    }else{
                        src = serverData.data.url;
                    }

                    if(typeof serverData.data.sizes.large != 'undefined'){
                        fullSrc = serverData.data.sizes.large.url;
                    }else {
                        fullSrc = serverData.data.url;
                    }

                    itemUploadedView = itemUploadedView.replace("{{full-src}}" , fullSrc);
                    itemUploadedView = itemUploadedView.replace("{{alt}}" , _alt);
                    itemUploadedView = itemUploadedView.replace("{{src}}" , src);
                    item.html( itemUploadedView );
                }else{

                    itemUploadedView = itemUploadedView.replace("{{full-src}}" , serverData.data.url);
                    itemUploadedView = itemUploadedView.replace("{{alt}}" , _alt);
                    itemUploadedView = itemUploadedView.replace("{{src}}" , serverData.data.icon);
                    item.html( itemUploadedView + '<div class="filename"><div>'+ serverData.data.filename +'</div></div>' );
                }

            }

        },

        render: function( callback ){
            var self = this;
            var options = self.options;
            var uploader;

            uploader = new plupload.Uploader(self.options);

            uploaders[self.id] = uploader;

            uploader.bind('BeforeUpload', function(up, file) {
                self.doAction("BeforeUpload" , [up, file]);
            });

            uploader.bind("UploadFile", function(up, file) {
                self.doAction("UploadFile" , [up, file]);
                $('#' + file.id).addClass('sed-uploader-current-file');
            });

            uploader.bind("Init", function(up, res) {
                self.doAction("Init" , [up, res]);
                //$(self.containerSelector).attr('title', 'Using runtime: ' + res.runtime);


                if( self.options.drop_element && up.features.dragdrop ){
                    var dropzone = $("#" + self.options.drop_element) ,
                        timer, active;
        			dropzone.toggleClass( 'supports-drag-drop', true );

        			// 'dragenter' doesn't fire correctly, simulate it with a limited 'dragover'.
        			dropzone.bind( 'dragover.sed-uploader', function() {
        				if ( timer ) {
        					clearTimeout( timer );
        				}

        				if ( active ) {
        					return;
        				}

        				dropzone.trigger('dropzone:enter').addClass('drag-over');
        				active = true;
        			});

        			dropzone.bind('dragleave.sed-uploader, drop.sed-uploader', function() {
        				// Using an instant timer prevents the drag-over class from
        				// being quickly removed and re-added when elements inside the
        				// dropzone are repositioned.
        				//
        				// @see https://core.trac.wordpress.org/ticket/21705
        				timer = setTimeout( function() {
        					active = false;
        					dropzone.trigger('dropzone:leave').removeClass('drag-over');
        				}, 0 );
        			});

                }/*else{
                    var dropzone = $("#" + self.id + '-drop-area');
        			dropzone.toggleClass( 'supports-drag-drop', !! dragdrop );

        			dropzone.unbind('.sed-uploader');
                }  */

                if(self.options.auto_render === false){
                    $('.sed-upload-start', self.target).click(function(e) {
                        uploader.start();
                        e.preventDefault();
                    });

                    $('.sed-upload-stop', self.target).click(function(e) {
                        e.preventDefault();
                        uploader.stop();
                    });
                }

            });


            uploader.bind("Error", function(up, err) {
                //var file = err.file, message;
                self.doAction("Error" , [up, err]);

                function destroy() {
                    delete uploaders[self.id];
                    uploader.destroy();
                    self.target.html(self.contentsBak);
                    uploader = self.target = self.contentsBak = null;
                }

                if (err.code === plupload.INIT_ERROR) {
                    setTimeout(function() {
                        destroy();
                    }, 1);
                }

                var error = self.mediaErrorView;
                error = error.replace("{{err-code}}" , err.code);
                error = error.replace("{{err-message}}" , err.message);
                $(error).appendTo( $( self.errorsSelector ) );

            });

           /*
            uploader.bind("PostInit", function() {
                // features are populated only after input components are fully instantiated
                //if (up.settings.dragdrop && up.f eatures.dragdrop) {
                    //$( self.itemsSelector ).append('<li class="plupload_droptext">' + _("Drag files here.") + '</li>');
                //}
            });*/

            uploader.init();


            /*uploader.bind("StateChanged", function() {

            }); */

            uploader.bind("FilesAdded", function(up, files) {
                uploader.start();
                self.doAction("FilesAdded" , [up, files]);
                $.each(uploader.files, function(i, file) {
     
                    if (file.status != plupload.DONE) {
                        self.fileQueued(file);
                    }
                //document.getElementById('filelist').innerHTML += '<div id="' + file.id + '">' + file.name + ' (' + plupload.formatSize(file.size) + ') <b></b></div>';
                });
            });

            /*
            uploader.bind('FilesRemoved', function() {
            // since the whole file list is redrawn for every change in the queue
            // we need to scroll back to the file removal point to avoid annoying
            // scrolling to the bottom bug (see #926)
            //var scrollTop = $('#' + id + '_filelist').scrollTop();
            //$('#' + id + '_filelist').scrollTop(scrollTop);
            }); */

            uploader.bind("UploadProgress", function(up, file) {

                self.doAction("UploadProgress" , [up, file]);
                self.uploadProgress(up, file); 
                //document.getElementById(file.id).getElementsByTagName('b')[0].innerHTML = '<span>' + file.percent + "%</span>";
            });

            uploader.bind("FileUploaded", function(up, file, response) {
                self.doAction("FileUploaded" , [up, file, response.response]);
                self.uploadSuccess(file, response.response);
            });

            uploader.bind("UploadComplete", function(up, files) {
                self.doAction("UploadComplete",[up, files]);
            });

            // Call setup function
            if (self.options.setup) {
                self.options.setup(uploader);
            }

        }

   };


    // UPLOADER PLUGIN DEFINITION
    // =========================

    $.fn.seduploader = function (settings) {
        if (settings) {
            return this.each(function () {
                var target, id, uploaderUI , upTmpl;

                target = $(this);
                id = target.attr('id');

                if (!id) {
                    id = plupload.guid();
                    target.attr('id', id);
                }

                upTmpl = target.attr("sed-uploader-tmpl") || ("tmpl-" + id);
                uploaderUI = $( "#" + upTmpl ).html();

                settings = $.extend({
                    //dragdrop : true,
                    browse_button           : id + '-browse',
                    container               : id,
                    runtimes                : "html5,flash,silverlight,html4",
                    url                     : SED_UPLOAD_AJAX_URL,
                    flash_swf_url           : SEDEXTBASE.url + "/media/js/Moxie.swf",
                    silverlight_xap_url     : SEDEXTBASE.url + "/media/js/Moxie.xap",
                    filedataname            : "file",
                    auto_render             : true,
                    list_items              : false,
                }, settings);

                // Enable drag/drop (see PostInit handler as well)
                if (settings.dragdrop) {
                    settings.drop_element = id + '-drop-area';
                }
                var data = target.data('sed.uploader');

                if (!data) target.data('sed.uploader', (data = new SiteEditorUploader( id , target , uploaderUI, settings)));
            });
        } else {
			// Get uploader instance for specified element
			return uploaders[$(this[0]).attr('id')];
		}
    }

    $.fn.seduploader.Constructor = SiteEditorUploader;

    //var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });

    //this.$element.trigger(e);
    /*
    $(document)
        .on("FilesAdded", function(event , callback){
            if (callback && typeof(callback) === "function") {
                callback();
            }
        });

		this.bind('FilesAdded', onFilesAdded);

		this.bind('CancelUpload', onCancelUpload);

		this.bind('BeforeUpload', onBeforeUpload);

		this.bind('UploadFile', onUploadFile);

		this.bind('UploadProgress', onUploadProgress);

		this.bind('StateChanged', onStateChanged);

		this.bind('QueueChanged', calc);

		this.bind('Error', onError);

		this.bind('FileUploaded', onFileUploaded);

		this.bind('Destroy', onDestroy);  */

} (jQuery, mOxie ));
